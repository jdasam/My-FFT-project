<html>

<head>
    <script src="player.js"></script>
    <script src="dsp.js"></script>
    <script type="text/javascript" src="jquery-1.8.0.min.js"></script>
    <script type="text/javascript" src="chroma.js"></script>
</head>
<body>
    <input type="file" onchange="loadFile(this.files[0])">
    <input type="button" onclick="play()" value="PLAY">
    <canvas id="canvas" width="800" height="512" style="display: block; background-color: black ;"></canvas>

</body>
<script>
    //var fft = new FFT.complex(1, false);
    //fft.simple(fftOutput, audioBuffer);
    var fftSize = 4096;
    var samplingRate = 44100;
    var frequencyBinSize = samplingRate/fftSize;

    var ctx = $("#canvas").get()[0].getContext("2d");

    // create a temp canvas we use for copying
    var tempCanvas = document.createElement("canvas"),
        tempCtx = tempCanvas.getContext("2d");
    tempCanvas.width=800;
    tempCanvas.height=512;

    // used for color distribution
    var hot = new chroma.ColorScale({
        colors:['#000000', '#ff0000', '#ffff00', '#ffffff'],
        positions:[0, .25, .75, 1],
        mode:'rgb',
        limits:[0, 300]
    });

    var blackmanAlpha = 0.16
    var blackman0 = (1-blackmanAlpha)/2
    var blackman1 = 1/2
    var blackman2 = blackmanAlpha/2

    var smoothingTimeConstant = 0.1;


    
    var dummyArray = new Array(fftSize/2);
    for (var i=0; i<fftSize/2; i++){
        dummyArray[i] = 0;
    }
    

    var PITCH_MIN = 36;
    var PITCH_MAX = 96;
    var PITCH_STEP = 0.25;
    var pitch_range = [];
    var pitch_range_hz = [];
    var NUM_HARMONICS = 15; 




    function test(input) {
        var fft = new FFT(1024, 44100);
        fft.forward(input);
        var spectrum = fft.spectrum;
    }

    function doFFT(input){
        var result = {};
        var smoothingBuffer = dummyArray;

        for (var i=0, len = fftSize - input.length % fftSize; i<len; i++){
            input.push(0);
        }

        for (var i = 0, len = input.length; i<len; i = i+fftSize){
            var fft = new FFT(fftSize, 44100);
            var hop = input.slice(i, i+fftSize);
            hop = blackmanWindow(hop);
            fft.forward(hop);
            //fft.spectrum = smoothingFilters(fft.spectrum, 2);
            fft.spectrum = smoothing(fft.spectrum, smoothingBuffer);
            smoothingBuffer = fft.spectrum;
            var peakArray = peakDetection(fft.spectrum, 20);

            var totalRoughness = 0;
            for (var j = 0; j < 20; j++){
                for (var k = j+1; k < 20; k++){
                    totalRoughness += roughnessCalculation(peakArray[j], peakArray[k]);
                }
            }
            fft.spectrum = conversionToDB(fft.spectrum);
            console.log(fft.spectrum);
            drawSpectrogram(fft.spectrum);
            //console.log(fft.spectrum.length);
        }

        /*
        var output =  new complex_array.ComplexArray(input.length);
        //console.log(output[100])
        for (var i=0, len = input.length; i<len; i++){
            output[i] = input.getChannelData(0)[i]
        }
        //console.log(output[100])
        var fftOutput = output.FFT();
        return fftOutput
        */
        return (fft.spectrum)
    }

    function audioToMono(input){
        var left = input.getChannelData(0);
        var right = input.getChannelData(1);
        var result = new Array(left.length);
        for (var i = 0, len = input.length; i<len; i++){
            result[i] = left[i]/2 + right[i]/2
        }
        return result
    }


    function drawSpectrogram(array) {

        // copy the current canvas onto the temp canvas
        var canvas = document.getElementById("canvas");

        tempCtx.drawImage(canvas, 0, 0, 800, 512);

        // iterate over the elements from the array
        for (var i = 0; i < array.length; i++) {
            // draw each pixel with the specific color
            var value = array[i] + 250 // add number
            ctx.fillStyle = hot.getColor(value).hex();

            // draw the line at the right side of the canvas
            ctx.fillRect(800 - 1, 512 - i, 1, 1);
        }

        // set translate on the canvas
        ctx.translate(-1, 0);
        // draw the copied image
        ctx.drawImage(tempCanvas, 0, 0, 800, 512, 0, 0, 800, 512);

        // reset the transformation matrix
        ctx.setTransform(1, 0, 0, 1, 0, 0);

    }

    function blackmanWindow(array){
        var output = new Array
        for (var i = 0, len = array.length; i<len; i++){
            output[i] = array[i] * (blackman0 - blackman1 * Math.cos(2 * Math.PI * i / len) + blackman2 * Math.cos(4 * Math.PI * i /len))
        }
        return output
    }

    function smoothing(currentArray, bufferArray){
        var output = new Array
        for (var i = 0, len = currentArray.length; i<len; i++){
            output[i] = smoothingTimeConstant * bufferArray[i] + (1 - smoothingTimeConstant) * currentArray[i]
        }
        return output
    }

    function conversionToDB(array){
        var output = new Array
        for (var i = 0, len = array.length; i<len; i++){
            output[i] = 50 * Math.log(array[i]) / Math.log(10) ;
        }
        //console.log(output)
        return output
    }

    function smoothingFilters(array, filterWidth){
        var output = new Array(array.length);

        for (var i = 0, len = array.length; i<len; i++){
            console.log(array[i])
            if (i > filterWidth && i +filterWidth < array.length){
                var sum = 0;
                for (var k = -filterWidth; k <= filterWidth; k++){
                    sum += array[i+k];
                }

                output[i] = sum / (1 + 2 * filterWidth)                
            }
            else {
                output[i] = array[i]
            }

        }
        return output;
    }

    function peakDetection(array, peakNumber){
        var output = [];
        for (var i = 0, len = array.length; i<len; i++){
            if(array[i] > Math.max(array[i-3], array[i-2], array[i-1], array[i+1], array[i+2], array[i+3]))
                output.push([i, array[i]]);
        }
        output.sort(function(a,b){
            if (a[1] > b[1]) return -1;
            if (a[1] < b[1]) return 1;
            return 0;})
        output = output.slice(0,peakNumber);
        return output
    }

    function roughnessCalculation (sineA, sineB){
        var ampMin = Math.min(sineA[1], sineB[1]);
        var ampMax = Math.max(sineA[1], sineB[1]);
        var freqMin = (Math.min(sineA[0], sineB[0]) +0.5) * frequencyBinSize;
        var freqMax = (Math.max(sineA[0], sineB[0]) +0.5) * frequencyBinSize;

        var X = ampMin * ampMax
        var Y = 2 * ampMin / (ampMin + ampMax)
        var Z = Math.exp(-3.5 * 0.24/(0.0207 * freqMax +18.96) * (freqMax - freqMin)) - Math.exp(-5.75 * 0.24/(0.0207 * freqMax +18.96) * (freqMax - freqMin)) 

        return Math.pow(X,0.1) * 0.5 * Math.pow(Y,3.11) * Z
    }


    function pitchDetection(dataArray){



        var comb_filter = new Array(dataArray.length);
        var sum_filter = new Array(dataArray.length);
        for (var i = 0; i < dataArray.length; i++) {
            comb_filter[i] = new Array(pitch_range.length);
            sum_filter[i] = new Array(pitch_range.length);
        }

        var binfrqs = [];
        for (var i = 0;i < dataArray.length; i++) {
            binfrqs[i] = i/fftSize*samplingRate;
        }

        var FLAG = true;
        // pitch range of interest
        for (var pitch = 0; pitch < pitch_range.length; pitch++) 
        {
            for (var f= 0;f< dataArray.length; f++) {
                //Boundary
                if(binfrqs[f] > NUM_HARMONICS*pitch_range_hz[pitch]) {
                    comb_filter[f][pitch] = 0;
                    sum_filter[f][pitch] = 0;
                }

                else if(binfrqs[f] < pitch_range_hz[pitch]/2) {
                    comb_filter[f][pitch] = 0;
                    sum_filter[f][pitch] = 0;
                }

                else {
                    comb_filter[f][pitch] = 0.5 * Math.cos(2*Math.PI*binfrqs[f]/pitch_range_hz[pitch]) + 0.5;

                    sum_filter[f][pitch] = 1;
                }
            }
        }   

        for(var f = 0; f < dataArray.length; f++) {
            //Convert to power instead of decible: Spec power
            dataArray[f] = Math.pow(10, dataArray[f]/10);

            //Spec power
            //dataArray[i] = Math.pow(dataArray[i], 2);
        }

        var pitch_gram = new Array(pitch_range.length);
        var energy = new Array(pitch_range.length);


        // Comb-filtering
        for(var p = 0; p < pitch_range.length; p++) {
            pitch_gram[p] = 0;
            energy[p] = 0;

            for(var f = 0; f < dataArray.length; f++) {
                pitch_gram[p] += (comb_filter[f][p] * dataArray[f]);
                energy[p] += (sum_filter[f][p] * dataArray[f]);
            }
        }

        console.log(pitch_gram)

    }

    function midi2hertz(midi) {
        var hertz;
        ///// YOUR CODE IS HERE /////
        var a = 440; // a is 440 hz...
        
        hertz = (a / 32) * Math.pow(2, (midi - 9) / 12);

        /////////////////////////////
        return hertz;
    }

</script>
</html>



